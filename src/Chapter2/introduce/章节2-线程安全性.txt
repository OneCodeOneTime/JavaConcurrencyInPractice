▲线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

▲无状态对象：既不包含任何域，也不包含任何对其他类中域的引用。

▲无状态对象一定是安全的。

▲++count：并不会作为一个不可分割的操作来执行，它包含了三个独立的操作：读取count的值，将值+1，然后将计算结果写入count。

▲竞态条件：由于不恰当的执行时序而出现不正确的结果。

▲最常见的竞态条件是：先检查后执行，即通过一个可能失效的观测结果来决定下一步的动作。比如你假如文件x不存在，然后创建文件x，但可能在你观察完文件
不存在和创建文件x之前的这段时间，有人创建了文件x，这就会导致各种问题。

▲竞态条件并不总是产生错误，还需要某种不恰当的执行时序。

▲为了确保线程安全性，“先检查后执行”和“读取-修改-写入”等操作必须是原子的。

▲java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。

▲原子变量只保证对同一个变量的状态改变是原子性的。多个变量的情况下，就算各个变量的状态改变是原子性的，但如果这些变量的值相互之间有依赖，或者约束，那么也不是线程安全的，
因此，当更新某一个变量时，需要在同一个原子操作中对其他变量进行更新。

▲要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

▲原子性：一组语句作为一个不可分割的单元被执行。

▲内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。获取锁的操作的粒度是“线程”。

▲子类的synchronized方法中如果调用父类的synchronized方法，并不是误解的两把锁：子类对象内置锁和父类对象内置锁，
人们往往以为构造子类对象的时候会同时构造它的父类的对象，毕竟持有一个指向父类的super引用，其实父类的构造器调用了不假，
但调用构造器不等于构造对象，所以其实只有一把锁，并不存在两把锁，内置锁是可重入的，所以子类的synchronized方法可以调用
父类的synchronized方法，这两个方法是使用同一个内置锁。


